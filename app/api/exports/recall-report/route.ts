import { NextRequest, NextResponse } from 'next/server'
import { prisma, withDatabaseErrorHandling } from '@/lib/db'

// POST /api/exports/recall-report - Generate comprehensive recall report for regulatory submissions
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { ingredientLotId, reason, reportedBy, incidentDate } = body
    
    if (!ingredientLotId || !reason || !reportedBy) {
      return NextResponse.json(
        {
          error: 'Missing required fields',
          code: 'VALIDATION_ERROR',
          details: { required: ['ingredientLotId', 'reason', 'reportedBy'] }
        },
        { status: 400 }
      )
    }
    
    // Generate comprehensive recall report
    const recallReport = await withDatabaseErrorHandling(
      async () => prisma.ingredientLot.findUnique({
        where: { id: parseInt(ingredientLotId) },
        include: {
          Ingredient: {
            select: {
              id: true,
              name: true,
              supplierName: true,
              supplierCode: true,
              storageType: true,
              allergens: true,
              certifications: true,
            }
          },
          BatchIngredient: {
            include: {
              ProductionRun: {
                include: {
                  Recipe: {
                    select: {
                      id: true,
                      name: true,
                      version: true,
                      description: true,
                    }
                  },
                  Pallet: {
                    select: {
                      id: true,
                      palletCode: true,
                      quantityPacked: true,
                      packingDate: true,
                      expirationDate: true,
                      shippingStatus: true,
                      location: true,
                      notes: true,
                      createdAt: true,
                    }
                  }
                }
              }
            }
          }
        }
      }),
      'Recall report generation query'
    )
    
    if (!recallReport) {
      return NextResponse.json(
        {
          error: 'Ingredient lot not found',
          code: 'NOT_FOUND',
          details: { ingredientLotId }
        },
        { status: 404 }
      )
    }
    
    const reportGeneratedAt = new Date()
    const allPallets = recallReport.BatchIngredient.flatMap(bi => bi.ProductionRun.Pallet)
    const affectedProductionRuns = recallReport.BatchIngredient.map(bi => bi.ProductionRun)
    
    // Calculate impact statistics
    const impact = {
      totalProductionRuns: affectedProductionRuns.length,
      totalPallets: allPallets.length,
      totalItems: allPallets.reduce((sum, p) => sum + (Number(p.quantityPacked) || 0), 0),
      totalWeight: allPallets.reduce((sum, p) => sum + (Number(p.quantityPacked) || 0), 0),
      shippedPallets: allPallets.filter(p => p.shippingStatus === 'shipped').length,
      inventoryPallets: allPallets.filter(p => p.shippingStatus === 'pending').length,
      recalledPallets: allPallets.filter(p => p.notes?.includes('RECALLED')).length,
      customerOrdersAffected: Array.from(new Set(
        allPallets.filter(p => p.notes?.includes('Order:')).map(p => p.notes)
      )),
    }
    
    // Generate CSV format recall report
    const csvHeaders = [
      // Report Header Information
      'Report Type',
      'Report Generated Date',
      'Report Generated By',
      'Incident Date',
      'Recall Reason',
      'Report ID',
      
      // Source Ingredient Information
      'Source Ingredient Lot ID',
      'Source Lot Code',
      'Source Ingredient Name',
      'Source Ingredient Type',
      'Source Supplier Name',
      'Source Supplier Lot Code',
      'Source Received Date',
      'Source Expiration Date',
      'Source Quantity Received',
      'Source Quality Status',
      'Source Current Status',
      'Source Allergens',
      
      // Impact Summary
      'Production Runs Affected',
      'Total Pallets Affected',
      'Total Items Affected',
      'Total Weight Affected (kg)',
      'Shipped Pallets',
      'Inventory Pallets',
      'Already Recalled Pallets',
      'Customer Orders Affected Count',
      'Customer Orders Affected List',
      
      // Affected Product Details
      'Batch Number',
      'Recipe Name',
      'Production Date',
      'Quantity Used',
      'Pallet Number',
      'Pallet Status',
      'Pallet Location',
      'Items Count',
      'Weight (kg)',
      'Customer Order',
      'Ship Date',
      
      // Risk Assessment
      'Severity Level',
      'Health Risk',
      'Allergen Risk',
      'Contamination Risk',
      
      // Regulatory Information
      'FDA Notification Required',
      'FSIS Notification Required',
      'State Notification Required',
      'Public Notification Required',
      'Retailer Notification Required',
      
      // Action Items
      'Immediate Actions Required',
      'Investigation Status',
      'Corrective Actions',
      'Preventive Actions',
      
      // Contact Information
      'Emergency Contact',
      'Regulatory Contact',
      'Customer Service Contact',
    ]
    
    // Generate rows for each affected pallet
    const csvRows = allPallets.map((pallet, index) => {
      const productionRun = affectedProductionRuns.find(pr => 
        pr.Pallet.some(p => p.id === pallet.id)
      )!
      
      const batchIngredient = recallReport.BatchIngredient.find(bi => 
        bi.productionRunId === productionRun.id
      )!
      
      // Risk assessment
      const allergenRisk = recallReport.Ingredient.allergens.length > 0 ? 'HIGH' : 'LOW'
      const healthRisk = reason.toLowerCase().includes('contamination') || 
                        reason.toLowerCase().includes('pathogen') ? 'CRITICAL' : 'MEDIUM'
      const severityLevel = healthRisk === 'CRITICAL' || allergenRisk === 'HIGH' ? 'CRITICAL' : 'HIGH'
      
      // Regulatory notifications
      const fdaRequired = severityLevel === 'CRITICAL' || 
                         recallReport.Ingredient.allergens.length > 0 ? 'YES' : 'NO'
      
      return [
        // Report Header (only on first row, empty for others)
        index === 0 ? 'FDA Recall Report' : '',
        index === 0 ? reportGeneratedAt.toISOString() : '',
        index === 0 ? reportedBy : '',
        index === 0 ? (incidentDate || reportGeneratedAt.toISOString()) : '',
        index === 0 ? reason : '',
        index === 0 ? `RECALL-${reportGeneratedAt.getTime()}` : '',
        
        // Source Ingredient Information (only on first row)
        index === 0 ? recallReport.id : '',
        index === 0 ? recallReport.internalLotCode : '',
        index === 0 ? recallReport.Ingredient.name : '',
        index === 0 ? recallReport.Ingredient.storageType : '',
        index === 0 ? recallReport.Ingredient.supplierName : '',
        index === 0 ? (recallReport.supplierLotCode || '') : '',
        index === 0 ? recallReport.receivedDate.toISOString().split('T')[0] : '',
        index === 0 ? (recallReport.expirationDate?.toISOString().split('T')[0] || '') : '',
        index === 0 ? recallReport.quantityReceived : '',
        index === 0 ? recallReport.qualityStatus : '',
        index === 0 ? recallReport.qualityStatus : '', // Using qualityStatus as status proxy
        index === 0 ? recallReport.Ingredient.allergens.join('; ') : '',
        
        // Impact Summary (only on first row)
        index === 0 ? impact.totalProductionRuns : '',
        index === 0 ? impact.totalPallets : '',
        index === 0 ? impact.totalItems : '',
        index === 0 ? impact.totalWeight.toFixed(2) : '',
        index === 0 ? impact.shippedPallets : '',
        index === 0 ? impact.inventoryPallets : '',
        index === 0 ? impact.recalledPallets : '',
        index === 0 ? impact.customerOrdersAffected.length : '',
        index === 0 ? impact.customerOrdersAffected.join('; ') : '',
        
        // Affected Product Details (each row)
        productionRun.dailyLot,
        productionRun.Recipe.name,
        productionRun.createdAt.toISOString().split('T')[0],
        batchIngredient.quantityUsed,
        pallet.palletCode || pallet.id.toString(),
        pallet.shippingStatus || '',
        pallet.location || '',
        Number(pallet.quantityPacked) || 0,
        Number(pallet.quantityPacked) || 0, // Using quantityPacked as weight proxy
        pallet.notes?.includes('Order:') ? pallet.notes : '',
        pallet.packingDate?.toISOString().split('T')[0] || '',
        
        // Risk Assessment (only on first row)
        index === 0 ? severityLevel : '',
        index === 0 ? healthRisk : '',
        index === 0 ? allergenRisk : '',
        index === 0 ? 'MEDIUM' : '', // Default contamination risk
        
        // Regulatory Information (only on first row)
        index === 0 ? fdaRequired : '',
        index === 0 ? 'NO' : '', // FSIS typically for meat/poultry
        index === 0 ? 'YES' : '', // State notification usually required
        index === 0 ? (severityLevel === 'CRITICAL' ? 'YES' : 'NO') : '',
        index === 0 ? (impact.shippedPallets > 0 ? 'YES' : 'NO') : '',
        
        // Action Items (only on first row)
        index === 0 ? 'Quarantine inventory; Contact customers; Halt production' : '',
        index === 0 ? 'INITIATED' : '',
        index === 0 ? 'Lot segregation; Root cause analysis; Supplier audit' : '',
        index === 0 ? 'Enhanced incoming inspection; Supplier qualification review' : '',
        
        // Contact Information (only on first row)
        index === 0 ? 'quality-manager@bakermaiden.com' : '',
        index === 0 ? 'regulatory@bakermaiden.com' : '',
        index === 0 ? 'customerservice@bakermaiden.com' : '',
      ]
    })
    
    // Convert to CSV format
    const csvContent = [
      csvHeaders.join(','),
      ...csvRows.map(row => row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
    ].join('\n')
    
    const filename = `recall-report-${recallReport.internalLotCode}-${reportGeneratedAt.toISOString().split('T')[0]}.csv`
    
    return new NextResponse(csvContent, {
      headers: {
        'Content-Type': 'text/csv; charset=utf-8',
        'Content-Disposition': `attachment; filename="${filename}"`
      }
    })
    
  } catch (error) {
    console.error('Error generating recall report:', error)
    
    return NextResponse.json(
      {
        error: 'Failed to generate recall report',
        code: 'EXPORT_ERROR',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}